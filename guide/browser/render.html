<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器渲染机制 | Jiuto&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="favicon.ico">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/jiuto_blog/assets/css/0.styles.9def4602.css" as="style"><link rel="preload" href="/jiuto_blog/assets/js/app.81157bac.js" as="script"><link rel="preload" href="/jiuto_blog/assets/js/2.63c13255.js" as="script"><link rel="preload" href="/jiuto_blog/assets/js/10.56f23f2b.js" as="script"><link rel="prefetch" href="/jiuto_blog/assets/js/11.28026f92.js"><link rel="prefetch" href="/jiuto_blog/assets/js/12.1f1bcc8c.js"><link rel="prefetch" href="/jiuto_blog/assets/js/13.c22e8ec2.js"><link rel="prefetch" href="/jiuto_blog/assets/js/14.52be2bcc.js"><link rel="prefetch" href="/jiuto_blog/assets/js/15.783e10d0.js"><link rel="prefetch" href="/jiuto_blog/assets/js/16.c58eaa7f.js"><link rel="prefetch" href="/jiuto_blog/assets/js/17.8f5c380a.js"><link rel="prefetch" href="/jiuto_blog/assets/js/18.4263c572.js"><link rel="prefetch" href="/jiuto_blog/assets/js/19.5f705808.js"><link rel="prefetch" href="/jiuto_blog/assets/js/20.3f3a1027.js"><link rel="prefetch" href="/jiuto_blog/assets/js/21.58433bff.js"><link rel="prefetch" href="/jiuto_blog/assets/js/22.2cc5575a.js"><link rel="prefetch" href="/jiuto_blog/assets/js/23.d77573c9.js"><link rel="prefetch" href="/jiuto_blog/assets/js/24.27381446.js"><link rel="prefetch" href="/jiuto_blog/assets/js/25.b0ddb7e4.js"><link rel="prefetch" href="/jiuto_blog/assets/js/26.a9e814ef.js"><link rel="prefetch" href="/jiuto_blog/assets/js/27.9bb3689d.js"><link rel="prefetch" href="/jiuto_blog/assets/js/28.222b7146.js"><link rel="prefetch" href="/jiuto_blog/assets/js/29.d3f93c65.js"><link rel="prefetch" href="/jiuto_blog/assets/js/3.8112d114.js"><link rel="prefetch" href="/jiuto_blog/assets/js/30.9a5081a5.js"><link rel="prefetch" href="/jiuto_blog/assets/js/31.997ed1b5.js"><link rel="prefetch" href="/jiuto_blog/assets/js/32.33bd9145.js"><link rel="prefetch" href="/jiuto_blog/assets/js/33.018f7cca.js"><link rel="prefetch" href="/jiuto_blog/assets/js/34.6fbf0882.js"><link rel="prefetch" href="/jiuto_blog/assets/js/35.97ecb6bd.js"><link rel="prefetch" href="/jiuto_blog/assets/js/36.3f087881.js"><link rel="prefetch" href="/jiuto_blog/assets/js/37.1b140e79.js"><link rel="prefetch" href="/jiuto_blog/assets/js/38.fbec478b.js"><link rel="prefetch" href="/jiuto_blog/assets/js/39.96a2717f.js"><link rel="prefetch" href="/jiuto_blog/assets/js/4.94733d25.js"><link rel="prefetch" href="/jiuto_blog/assets/js/40.3962ae85.js"><link rel="prefetch" href="/jiuto_blog/assets/js/41.a8f40a42.js"><link rel="prefetch" href="/jiuto_blog/assets/js/42.3a462eee.js"><link rel="prefetch" href="/jiuto_blog/assets/js/43.8dc4aae6.js"><link rel="prefetch" href="/jiuto_blog/assets/js/44.4142b4a5.js"><link rel="prefetch" href="/jiuto_blog/assets/js/45.3afc072f.js"><link rel="prefetch" href="/jiuto_blog/assets/js/46.e69472db.js"><link rel="prefetch" href="/jiuto_blog/assets/js/47.e9c5b99a.js"><link rel="prefetch" href="/jiuto_blog/assets/js/48.e09f6af8.js"><link rel="prefetch" href="/jiuto_blog/assets/js/49.00d12d6e.js"><link rel="prefetch" href="/jiuto_blog/assets/js/5.2ea06e07.js"><link rel="prefetch" href="/jiuto_blog/assets/js/50.f4eaa6cd.js"><link rel="prefetch" href="/jiuto_blog/assets/js/51.b266867f.js"><link rel="prefetch" href="/jiuto_blog/assets/js/52.a889cb0d.js"><link rel="prefetch" href="/jiuto_blog/assets/js/53.8e24f4a5.js"><link rel="prefetch" href="/jiuto_blog/assets/js/54.a5743371.js"><link rel="prefetch" href="/jiuto_blog/assets/js/55.8ecd4c3b.js"><link rel="prefetch" href="/jiuto_blog/assets/js/56.8af4197e.js"><link rel="prefetch" href="/jiuto_blog/assets/js/57.d669494c.js"><link rel="prefetch" href="/jiuto_blog/assets/js/58.5d8030d0.js"><link rel="prefetch" href="/jiuto_blog/assets/js/59.24c2f863.js"><link rel="prefetch" href="/jiuto_blog/assets/js/6.8d81f0ec.js"><link rel="prefetch" href="/jiuto_blog/assets/js/7.ff1ba223.js"><link rel="prefetch" href="/jiuto_blog/assets/js/8.8c5bf8b0.js"><link rel="prefetch" href="/jiuto_blog/assets/js/9.935945b7.js">
    <link rel="stylesheet" href="/jiuto_blog/assets/css/0.styles.9def4602.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/jiuto_blog/" class="home-link router-link-active"><!----> <span class="site-name">Jiuto's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/Jiuto" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/Jiuto" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiuto_blog/guide/js/eventBus.html" class="sidebar-link">用Map写一个EventBus事件总线</a></li><li><a href="/jiuto_blog/guide/js/promise.html" class="sidebar-link">手写一个Promise</a></li><li><a href="/jiuto_blog/guide/js/babble_capture.html" class="sidebar-link">冒泡与捕获</a></li><li><a href="/jiuto_blog/guide/js/debounce_throttle.html" class="sidebar-link">防抖与节流</a></li><li><a href="/jiuto_blog/guide/js/clone.html" class="sidebar-link">浅拷贝和深拷贝</a></li><li><a href="/jiuto_blog/guide/js/module.html" class="sidebar-link">ES6 Module</a></li><li><a href="/jiuto_blog/guide/js/template.html" class="sidebar-link">模板引擎原理</a></li><li><a href="/jiuto_blog/guide/js/closure.html" class="sidebar-link">理解js闭包</a></li><li><a href="/jiuto_blog/guide/js/proto.html" class="sidebar-link">理解js原型、原型链和继承</a></li><li><a href="/jiuto_blog/guide/js/new.html" class="sidebar-link">手写 new 操作符</a></li><li><a href="/jiuto_blog/guide/js/bind.html" class="sidebar-link">手写 bind</a></li><li><a href="/jiuto_blog/guide/js/apply_call.html" class="sidebar-link">手写 apply 和 call</a></li><li><a href="/jiuto_blog/guide/js/let_const.html" class="sidebar-link">let、const和块级作用域</a></li><li><a href="/jiuto_blog/guide/js/curry.html" class="sidebar-link">柯里化</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>CSS</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiuto_blog/guide/css/flex.html" class="sidebar-link">flex布局</a></li><li><a href="/jiuto_blog/guide/css/layout.html" class="sidebar-link">常见布局</a></li><li><a href="/jiuto_blog/guide/css/bfc.html" class="sidebar-link">BFC 块格式化上下文</a></li><li><a href="/jiuto_blog/guide/css/stacking_context.html" class="sidebar-link">层叠上下文、层叠层级、层叠顺序</a></li><li><a href="/jiuto_blog/guide/css/center.html" class="sidebar-link">水平居中、垂直居中</a></li><li><a href="/jiuto_blog/guide/css/grid.html" class="sidebar-link">grid 网格布局</a></li><li><a href="/jiuto_blog/guide/css/css3.html" class="sidebar-link">CSS3 动画</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiuto_blog/guide/vue/nextTick.html" class="sidebar-link">vue中$nextTick的实现原理</a></li><li><a href="/jiuto_blog/guide/vue/responsive.html" class="sidebar-link">简单实现vue响应式原理</a></li><li><a href="/jiuto_blog/guide/vue/initData.html" class="sidebar-link">源码分析vue响应式原理</a></li><li><a href="/jiuto_blog/guide/vue/initWatch.html" class="sidebar-link">源码分析vue watch侦听器</a></li><li><a href="/jiuto_blog/guide/vue/patch.html" class="sidebar-link">源码阅读vue VirtualDOM 和 diff</a></li><li><a href="/jiuto_blog/guide/vue/initComputed.html" class="sidebar-link">源码分析vue computed</a></li><li><a href="/jiuto_blog/guide/vue/router.html" class="sidebar-link">源码阅读vue-router</a></li><li><a href="/jiuto_blog/guide/vue/vuex.html" class="sidebar-link">源码阅读vuex</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>webpack</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiuto_blog/guide/webpack/webpack_template.html" class="sidebar-link">webpack多页面打包方法工具和模板</a></li><li><a href="/jiuto_blog/guide/webpack/babeltry.html" class="sidebar-link">通过babel手撸超简化版webpack</a></li><li><a href="/jiuto_blog/guide/webpack/plugin_loader.html" class="sidebar-link">手写webpack plugin 和 loader</a></li><li><a href="/jiuto_blog/guide/webpack/babel_plugin.html" class="sidebar-link">写一个Babel插件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiuto_blog/guide/browser/eventloop.html" class="sidebar-link">event loop 事件循环</a></li><li><a href="/jiuto_blog/guide/browser/render.html" aria-current="page" class="active sidebar-link">浏览器渲染机制</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络与安全</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiuto_blog/guide/network/http.html" class="sidebar-link">http、https</a></li><li><a href="/jiuto_blog/guide/network/cache.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/jiuto_blog/guide/network/cross.html" class="sidebar-link">跨域</a></li><li><a href="/jiuto_blog/guide/network/security.html" class="sidebar-link">web 安全</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiuto_blog/guide/algorithm/editDistance.html" class="sidebar-link">从最短编辑距离问题到初识动态规划</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>其他</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/jiuto_blog/guide/else/ele_expend.html" class="sidebar-link">如何在element-ui中拓展一个新的组件</a></li><li><a href="/jiuto_blog/guide/else/cli.html" class="sidebar-link">搭建一个脚手架工具</a></li><li><a href="/jiuto_blog/guide/else/utils.html" class="sidebar-link">搭建一个方法库</a></li><li><a href="/jiuto_blog/guide/else/auto_deploy.html" class="sidebar-link">搭建一个自动化部署服务</a></li><li><a href="/jiuto_blog/guide/else/docker_verdaccio.html" class="sidebar-link">在docker中通过Verdaccio搭建一个私有npm库</a></li><li><a href="/jiuto_blog/guide/else/docker_initSql.html" class="sidebar-link">通过Dockerfile在docker中初始化mysql表</a></li><li><a href="/jiuto_blog/guide/else/eslint_prettier.html" class="sidebar-link">在vue/react项目中配置eslint + prettier</a></li><li><a href="/jiuto_blog/guide/else/karma_mocha.html" class="sidebar-link">搭建一个由 karma + mocha + chai + Istanbul 组成的基础测试工具</a></li><li><a href="/jiuto_blog/guide/else/optimization.html" class="sidebar-link">首屏加载优化</a></li><li><a href="/jiuto_blog/guide/else/docker.html" class="sidebar-link">如何使用docker发布项目</a></li><li><a href="/jiuto_blog/guide/else/interview.html" class="sidebar-link">面试路漫漫2021</a></li><li><a href="/jiuto_blog/guide/else/interview23.html" class="sidebar-link">面试准备2023</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="header-anchor">#</a> 浏览器渲染机制</h2> <h3 id="浏览器进程"><a href="#浏览器进程" class="header-anchor">#</a> 浏览器进程</h3> <blockquote><ul><li>浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li> <li>渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li> <li>GPU 进程：其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li> <li>网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li> <li>插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul></blockquote> <p>这里的排版引擎就是我们通常说的渲染引擎，也有叫浏览器内核的。</p> <p>常见浏览器内核：Trident =&gt; IE、Gecko =&gt; Firefox、Webkit =&gt; Safari/Chrome、Presto =&gt; Opera</p> <h3 id="在浏览器里-从输入-url-到页面展示-这中间发生了什么"><a href="#在浏览器里-从输入-url-到页面展示-这中间发生了什么" class="header-anchor">#</a> “在浏览器里，从输入 URL 到页面展示，这中间发生了什么？ ”</h3> <h4 id="_1-用户输入url"><a href="#_1-用户输入url" class="header-anchor">#</a> 1. 用户输入URL</h4> <p>浏览器判断输入内容是否为URL，如果不是URL，用浏览器默认的搜索引擎来合成新的带搜索关键字的URL，如果判断输入内容符合URL规则，则加上协议合成完整URL。</p> <h4 id="_2-url请求"><a href="#_2-url请求" class="header-anchor">#</a> 2. URL请求</h4> <ol><li><p>浏览器进程通过进程间通信（IPC）把URL请求发送至网络进程，由网络进程发起真正的URL请求。</p></li> <li><p>网络进程查找本地缓存是否缓存了该资源，如果有缓存资源，那么直接返回资源给浏览器进程，如果没有缓存则进入网络请求流程。</p></li> <li><p>请求前第一步进行DNS解析，以获取请求域名的服务器IP地址。如果请求协议是HTTPS，需要建立TLS连接。</p></li> <li><p>利用IP地址和服务器建立TCP连接。</p></li> <li><p>构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，然后向服务器发送构建的请求信息。</p></li> <li><p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。</p></li> <li><p>网络进程接收到响应后，解析响应头的内容。</p></li></ol> <ul><li><p>如果返回的状态码是301或者302，从响应头的 Location 字段读取重定向的地址，发起新的 HTTP 或者 HTTPS 请求。</p></li> <li><p>如果响应行是200，根据Content-Type，判断服务器返回的响应体数据是什么类型，如果响应头中的Content-type字段的值是text/html，说明服务器返回的数据是HTML格式。</p></li></ul> <h4 id="_3-准备渲染进程"><a href="#_3-准备渲染进程" class="header-anchor">#</a> 3. 准备渲染进程</h4> <p>同一站点：根域名（例如，geekbang.org）和协议（例如，https:// 或者 http://）相同的页面。</p> <p>Chrome 默认会为每个页面分配一个渲染进程，但是，如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。</p> <h4 id="_4-提交文档-即响应体数据"><a href="#_4-提交文档-即响应体数据" class="header-anchor">#</a> 4. 提交文档（即响应体数据）</h4> <ol><li><p>浏览器进程发出“提交请求”消息给渲染进程，渲染进程接收到“提交文档”的消息后，和网络进程建立传输数据的“管道”。</p></li> <li><p>等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。</p></li> <li><p>浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新Web页面。</p></li></ol> <h4 id="_5-渲染流程"><a href="#_5-渲染流程" class="header-anchor">#</a> 5. 渲染流程</h4> <ol><li>构建DOM树</li></ol> <p>浏览器从响应体读取HTML原始字节，并指定编码(如UTF-8)转换成字符串，
再将字符串转换成Token，Token会标识是“开始标签”、“结束标签”或“文本”等信息，如&quot;StartTag:head&quot;、&quot;EndTag:title&quot;、&quot;sometext&quot;，
然后由Token生成节点对象，最后构建DOM树。</p> <blockquote><p>事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。
换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。注意：带有结束标签标识的Token不会创建节点对象。</p></blockquote> <ol start="2"><li>构建CSSOM树</li></ol> <p>构建CSSOM的过程与构建DOM的过程相似。</p> <p>CSS 样式来源主要有三种：</p> <ul><li>通过 link 引用的外部 CSS 文件</li> <li><code>&lt;style&gt;</code>标记内的 CSS</li> <li>元素的 style 属性内嵌的 CSS</li></ul> <p>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式既可以自行设置给某个节点，也可以通过继承获得。
在这一过程中，浏览器得递归CSSOM树，确定具体的元素样式。</p> <ol start="3"><li>构建渲染树（布局树）</li></ol> <p>遍历DOM树中的所有可见节点，并把这些节点添加到渲染树，不可见的节点会被忽略掉，如head标签下面的全部内容、样式属性包含dispaly:none的元素等。</p> <p>计算渲染树节点的坐标位置。</p> <ol start="4"><li>构建分层树</li></ol> <p>渲染引擎为特定的节点生成专用的图层，并生成一棵对应的图层树。</p> <p>这涉及到层叠上下文，可以看看这篇文章：<a href="https://jiuto.github.io/jiuto_blog/guide/css/stacking_context.html" target="_blank" rel="noopener noreferrer">层叠上下文、层叠层级、层叠顺序<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <ol start="5"><li>生产绘制列表</li></ol> <p>把每一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。</p> <p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。</p> <p>所以这一步还要将绘制列表提交到合成线程。</p> <ol start="6"><li>栅格化</li></ol> <blockquote><p>合成线程会将图层划分为图块（tile），按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。
所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。
渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。
通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p></blockquote> <ol start="7"><li>合成</li></ol> <p>所有图块都被光栅化后，合成线程发送绘制图块的命令DrawQuad给浏览器进程。</p> <ol start="8"><li>显示</li></ol> <p>浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p> <h3 id="理解回流-重排-、重绘、合成"><a href="#理解回流-重排-、重绘、合成" class="header-anchor">#</a> 理解回流（重排）、重绘、合成</h3> <h4 id="回流-重排"><a href="#回流-重排" class="header-anchor">#</a> 回流（重排）</h4> <p>当渲染树中部分或全部元素的更改，能引起元素的几何位置属性，例如改变元素的宽度、高度等，浏览器会触发重新布局，这个过程称为回流或者重排。</p> <p>会导致回流的操作：</p> <ul><li>页面首次渲染</li> <li>浏览器窗口大小发生改变</li> <li>元素尺寸或位置发生改变（边距、填充、边框、宽度和高度）</li> <li>元素内容变化（文字数量或图片大小等等）</li> <li>元素字体大小变化</li> <li>添加或者删除可见的DOM元素</li> <li>计算 offsetWidth 和 offsetHeight 属性</li> <li>设置/查询某些属性、调用某些方法</li></ul> <p>常见的会导致回流的属性和方法：</p> <ul><li>width、height、margin、padding、border</li> <li>display、position、overflow</li> <li>clientWidth、clientHeight、clientTop、clientLeft</li> <li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li> <li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li> <li>scrollIntoView()、scrollIntoViewIfNeeded()</li> <li>getComputedStyle()</li> <li>getBoundingClientRect()</li> <li>scrollTo()</li></ul> <h4 id="重绘"><a href="#重绘" class="header-anchor">#</a> 重绘</h4> <p>当页面中元素样式的改变并不影响它在文档流中的位置时，例如修改了元素的背景颜色，由于没有引起几何位置的变换，所以不会重新执行布局，浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p> <p>相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</p> <p>常见的会导致重绘的属性和方法：</p> <ul><li>color、text-decoration、visibility</li> <li>background、background-image、background-position、background-repeat、background-size</li> <li>outline、outline-color、outline-style、outline-radius、outline-width</li> <li>border-style、box-shadow</li></ul> <h4 id="合成"><a href="#合成" class="header-anchor">#</a> 合成</h4> <p>更改一个既不要布局也不要绘制的属性，例如使用CSS的transform来实现动画效果，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。</p> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <p>回流必将引起重绘，重绘不一定会引起回流。</p> <p>减少回流和重绘：</p> <ul><li>使用 transform 替代 top</li> <li>使用 visibility 替换 display: none</li> <li>不要把节点的属性值放在一个循环里当成循环里的变量</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.test'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>offsetTop<span class="token punctuation">)</span><span class="token comment">// 获取 offsetTop 会导致回流</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>尽量避免使用 table 布局</li></ul> <blockquote><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p> <p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p> <ul><li>clientWidth、clientHeight、clientTop、clientLeft</li> <li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li> <li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li> <li>width、height</li> <li>getComputedStyle()</li> <li>getBoundingClientRect()
因为队列中可能会有影响到这些属性或方法返回值的操作，即使你希望获取的信息与队列中操作引发的改变无关，浏览器也会强行清空队列，确保你拿到的值是最精确的。</li></ul></blockquote> <h3 id="其他"><a href="#其他" class="header-anchor">#</a> 其他</h3> <h4 id="渲染过程中遇到js文件怎么处理"><a href="#渲染过程中遇到js文件怎么处理" class="header-anchor">#</a> 渲染过程中遇到JS文件怎么处理</h4> <p>JavaScript的加载、解析与执行会阻塞DOM的构建，所以为了加快首屏渲染，建议将script标签放在body标签底部，或者，也可以给script标签添加<code>defer</code>或者<code>async</code>属性。</p> <p>JS文件会导致CSSOM阻塞DOM的构建，因为JavaScript既可以更改DOM，也可以更改CSS，不完整的CSSOM是无法使用的，在执行js时，必须要拿到完整的CSSOM，这就导致了一个现象，如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行js脚本，那么浏览器必须优先完成CSSOM的下载和构建，然后再执行js脚本，最后再继续构建DOM。</p> <p>关于<code>defer</code>和<code>async</code>：</p> <ul><li><code>&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</li> <li><code>&lt;script async src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行。</li> <li><code>&lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt;</code>defer 属性表示延迟执行js，设置了defer的js加载不会阻塞dom构建，即js加载时HTML并未停止解析，这两个过程是并行的，都完成后才会执行由defer-script加载的脚本。</li> <li>在加载多个JS脚本的时候，async是无顺序的加载，而defer是有顺序的加载。</li></ul> <h4 id="为什么操作-dom-慢"><a href="#为什么操作-dom-慢" class="header-anchor">#</a> 为什么操作 DOM 慢</h4> <p>因为DOM属于渲染引擎，而JS在JS引擎中执行。通过JS操作DOM涉及到两个线程之间的通信，并且操作DOM可能还会带来重绘回流的情况。</p> <h4 id="渲染页面时常见哪些不良现象"><a href="#渲染页面时常见哪些不良现象" class="header-anchor">#</a> 渲染页面时常见哪些不良现象</h4> <blockquote><p>由于浏览器的渲染机制不同，在渲染页面时会出现两种常见的不良现象—-白屏问题和FOUS（无样式内容闪烁）。</p> <p>FOUC：由于浏览器渲染机制（比如firefox），在CSS加载之前，先呈现了HTML，就会导致展示出无样式内容，然后样式突然呈现的现象。</p> <p>白屏：有些浏览器渲染机制（比如chrome）要先构建DOM树和CSSOM树，构建完成后再进行渲染，如果CSS部分放在HTML尾部，由于CSS未加载完成，浏览器迟迟未渲染，从而导致白屏；也可能是把js文件放在头部，脚本会阻塞后面内容的呈现，脚本会阻塞其后组件的下载，出现白屏问题。</p></blockquote> <h3 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h3> <p><a href="https://time.geekbang.org/column/intro/100033601" target="_blank" rel="noopener noreferrer">浏览器工作原理与实践-极客时间<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html" target="_blank" rel="noopener noreferrer">浏览器内核的解析和对比<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://zhuanlan.zhihu.com/p/53913989" target="_blank" rel="noopener noreferrer">深入浅出浏览器渲染原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903569087266823" target="_blank" rel="noopener noreferrer">浏览器的回流与重绘 (Reflow &amp; Repaint)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/jiuto_blog/guide/browser/eventloop.html" class="prev">
        event loop 事件循环
      </a></span> <span class="next"><a href="/jiuto_blog/guide/network/http.html">
        http、https
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/jiuto_blog/assets/js/app.81157bac.js" defer></script><script src="/jiuto_blog/assets/js/2.63c13255.js" defer></script><script src="/jiuto_blog/assets/js/10.56f23f2b.js" defer></script>
  </body>
</html>
